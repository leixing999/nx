

## 一 逆向编程基础篇

### 1.0 概述

 #### 1.1 多字节存储顺序

CPU存储方式分为大端存储（正序）和小端存储（逆序）。

​    现在将12345678H 写入以10000H开始的内存中为例。

+ **CPU 大端模式，存放数据**

  大端存储方式是将**数据高位**放到**低地址中**去。

​      

| 数据 | 地址   |
| ---- | ------ |
| 12H  | 10000H |
| 34H  | 10001H |
| 56H  | 10002H |
| 78H  | 10003H |

+ **CPU小端模式**

小端存储方式是将**数据高位**放到**高地址中**去。



| 数据 | 地址   |
| ---- | ------ |
| 78H  | 10000H |
| 56H  | 10001H |
| 34H  | 10002H |
| 12H  | 10003H |

#### 1.2 ASCII和Unicode 编码

+ **ASCII**编码

  ASCII编码用一个字节表示计算机数据。（0-255）

+ Unicode是用两个字节表示编码范围（0-65535）

​     它包含了**UTF-8，UTF-16和UTF-32**三种编码，其中ASCII编码是Unicode编码的一部分。

+ **WORD和DWORD**

  **WORD** 表示2个字节

  **DWORD** 表示4个字节

  

   + **例子存储方式（小端模式）**

     以字符串**fishc**例子：其中按照Unicode方式存储，其中**字符串是从做到右**是高位到地方排放的方式。

     f 对应的16进制编码：0066H

     i对应的16进制编码：  0069H

     s对应的16进制编码： 0073H

     h对应的16进制编码： 0068H

     c对应的16进制编码： 0063H

     **fishc**在CPU中16进制排列顺序是：0063 0068 0073 0069 0066H排列，此表格是按照CPU**小端方式排列**

     | 内容 | 66H  | 00H   | 69H   | 00H  | 73H  | 00H  | 68H  | 00H  | 63H  | 00H  |
     | ---- | ---- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
     | 地址 | 1000 | 10001 | 10002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 |

     

#### 1.3 Win API函数与stdcall约定



+ Windows 标准调用是__stdcall，但是在C语言标准是''__cdecl

​     (1) 定义**函数入栈**顺序是**自右向左**方式。





#### 1.4 Windows消息机制



#### 1.5 windows模式

+ **实模式**

   1. **80X86**是使用CS寄存器配合IP寄存器来通知CPU指令在内存的位置

   2. **X86**定位内存索引内存是通过**段地址+偏移地址 = 20位物理地址**，例如：

      ~~~ 
      段地址（2000H） + 偏移地址（20H） = （物理地址）20020H

​    3. 程序指令在执行过程中一般还需要的各种数据，x86系列有**CS、DS、ES、FS、SS**等用于指示不同用的数据段在内存中的位置。

​       **CS** 表示代码段。

​       **DS**表示数据段。

    4. **X86**系列使用**中断机制**来实现系统服务。
       5. **寄存器**（ALL）8bit->(AX)16bit->(EAX)32bit->(RAX)64bit



+ **保护模式**

1.  和实模式下一样，保护模式下程序运行的实质仍是**CPU执行指令，操作相关数据**。主要改变的是**寻址的方式**，保护模式在寻址方式上**动了手脚**

 ，为的是起到**保护的作用**。

2. **不同任务之间的保护**： 通过把每个不同的任务放在不同的**虚拟地址空间**中，来实现不同任务之间的间隔（即A程序不能访问和修改B程序的代码和数据），

   已达到程序间的隔离。

3. **同一人任务的保护**： 在每一任务之内定义了4中保护级别，分别为0、1、2、3，按环的方式表示。

   ![img](https://img2020.cnblogs.com/blog/733795/202005/733795-20200531165433957-1276035254.png)

   4. **虚拟内存**

   ​    -->**虚拟内存**并不是真正的内存，他是通过映射（Map）的方法，使可用的虚拟内存（VA）达到4GB（因为**EIP** 32位的索引的最大范围是4GB）。

   ​    -->**这样规定**：每个应用程序可以被分配到2GB的虚拟地址，省下的2GB留给操作系统自己用（Windows NT中，应用程序甚至有3GB的虚拟地址）。

   

   

   

+ **虚拟8086模式**

#### 1.6 PE结构

1. **PE结构部分内容**

+ **.text**

  是在编译或汇编结束时产生的一种块，他的内容全是**指令代码**。

+ **.rdata**

  是运行期制度数据。

+ **data**

  是初始化的数据块。

+ **.idata**

​     包含其他外来的**DLL的函数及数据**信息，即**输入表**。

 + **.rsrc**

   包含模块的全部资源：如图标、菜单、位图等。

   

2. **PE结构硬盘和内存映射关系**

   ![img](https://pic002.cnblogs.com/images/2012/345752/2012090211123230.png)

3. **PE相关名词点解释**

   + **入口点**

​         PE文件执行时的入口点，也就是说，程序在执行时的第一行代码地址应该就是这个值。有点像8086汇编语言中的end start 中的start指向的入口地址。

   + **文件的偏移地址**

     当PE文件存储在磁盘上的时候，各数据的地址称作文件的偏移地址，文件的偏移地址从PE文件的第一个地址开始，以0地址开始。

+ **虚拟地址（VA）**

  由于Windows程序运行在保护模式下，所以应用程序访问存储器所使用的的**逻辑地址**称为虚拟地址（因为他不是真正的物理地址），真正的物理地址被windows保护机制保护起来，又称为内存偏移地址（Memory Offset）。

  

   + **基地址（ImageBase）**

     --->文件执行时将被映射到指定内存地址中，这个初始内存地址成为基地址，这个值是有PE文件本身设定的。

     ---> 按照默认设置，用Visual C++建立的EXE文件基地址是**00400000H**，DLL文件基地址是**10000000H**，但是这个值可以在**编译器上设定**。

     

     #### 1.7 PE结构详解



##### 1.7.1 PE结构定义

   PE格式定义的主要地方位于我们的头文件**winnt.h**,这个头文件中，几乎能找到关于PE文件所有定义。

![img](https://img-blog.csdnimg.cn/20181214004508852.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20181214004548351.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70)





![PE详细结构定义](E:\develop\逆向\nx\PE详细结构定义.jpg)



![PE详细结构定义2](E:\develop\逆向\nx\PE详细结构定义2.jpg)



